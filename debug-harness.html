<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Registry Client - Debug Harness</title>
  <link rel="stylesheet" href="src/styles/debug-harness.css">
</head>
<body>
  <div class="container">
    <header>
      <h1>WebRTC Registry Client - Debug Harness</h1>
      <p class="subtitle">Test room handshake protocol and peer-to-peer messaging</p>
    </header>

    <main>
      <!-- Configuration Section -->
      <section class="section config-section">
        <h2>Configuration</h2>
        <div class="form-group">
          <label for="registry-url">Registry API URL:</label>
          <input 
            type="text" 
            id="registry-url" 
            data-testid="registry-url"
            value="http://127.0.0.1:8787"
            placeholder="https://registry.example.com"
          />
        </div>
        <div class="form-group">
          <label for="stun-url">STUN Server URL:</label>
          <input 
            type="text" 
            id="stun-url"
            data-testid="stun-url"
            value="stun:stun.l.google.com:19302"
            placeholder="stun:stun.l.google.com:19302"
          />
        </div>
      </section>

      <!-- Role Selection -->
      <section class="section role-section">
        <h2>Select Role</h2>
        <div class="role-buttons">
          <button 
            id="role-host" 
            class="role-button" 
            data-testid="role-host"
          >
            Host
          </button>
          <button 
            id="role-guest" 
            class="role-button"
            data-testid="role-guest"
          >
            Guest
          </button>
        </div>
      </section>

      <!-- Host Interface -->
      <section id="host-interface" class="section hidden" data-testid="host-interface">
        <h2>Host Interface</h2>
        <div class="form-group">
          <label for="host-username">Your Username:</label>
          <input 
            type="text" 
            id="host-username"
            data-testid="host-username"
            placeholder="Enter your username"
            maxlength="32"
          />
        </div>
        <button 
          id="create-room-btn"
          class="action-button"
          data-testid="create-room-btn"
        >
          Create Room
        </button>

        <div id="room-created-info" class="info-box hidden" data-testid="room-created-info">
          <h3>Room Created!</h3>
          <div class="info-row">
            <label>Room Code:</label>
            <span id="room-code" class="code" data-testid="room-code"></span>
            <button id="copy-room-code" class="copy-btn" data-testid="copy-room-code">Copy</button>
          </div>
          <div class="info-row">
            <label>Join Code:</label>
            <span id="join-code" class="code" data-testid="join-code"></span>
            <button id="copy-join-code" class="copy-btn" data-testid="copy-join-code">Copy</button>
          </div>
          <div class="info-row">
            <label>Expires At:</label>
            <span id="expires-at" data-testid="expires-at"></span>
          </div>
          <button 
            id="start-connection-host-btn"
            class="action-button"
            data-testid="start-connection-host-btn"
          >
            Start Connection
          </button>
        </div>
      </section>

      <!-- Guest Interface -->
      <section id="guest-interface" class="section hidden" data-testid="guest-interface">
        <h2>Guest Interface</h2>
        <div class="form-group">
          <label for="guest-username">Your Username:</label>
          <input 
            type="text" 
            id="guest-username"
            data-testid="guest-username"
            placeholder="Enter your username"
            maxlength="32"
          />
        </div>
        <div class="form-group">
          <label for="guest-room-code">Room Code:</label>
          <input 
            type="text" 
            id="guest-room-code"
            data-testid="guest-room-code"
            placeholder="8-character room code"
            maxlength="8"
          />
        </div>
        <div class="form-group">
          <label for="guest-join-code">Join Code:</label>
          <input 
            type="text" 
            id="guest-join-code"
            data-testid="guest-join-code"
            placeholder="6-digit join code"
            maxlength="6"
          />
        </div>
        <button 
          id="join-room-btn"
          class="action-button"
          data-testid="join-room-btn"
        >
          Join Room
        </button>

        <div id="room-joined-info" class="info-box hidden" data-testid="room-joined-info">
          <h3>Joined Room!</h3>
          <div class="info-row">
            <label>Host:</label>
            <span id="host-name" data-testid="host-name"></span>
          </div>
          <button 
            id="start-connection-guest-btn"
            class="action-button"
            data-testid="start-connection-guest-btn"
          >
            Start Connection
          </button>
        </div>
      </section>

      <!-- Connection State -->
      <section class="section state-section">
        <h2>Connection State</h2>
        <div class="state-display">
          <div class="state-indicator" id="state-indicator" data-testid="state-indicator">
            <span class="state-dot"></span>
            <span class="state-text" id="state-text" data-testid="state-text">idle</span>
          </div>
        </div>
      </section>

      <!-- Debug Timeline -->
      <section class="section debug-section" data-testid="debug-section">
        <div class="section-header">
          <h2>Debug Timeline</h2>
          <div class="log-controls">
            <button
              id="collapse-debug-log"
              class="log-control-btn"
              type="button"
              aria-pressed="false"
              data-testid="collapse-debug-log"
            >
              Collapse Entries
            </button>
            <button
              id="clear-debug-log"
              class="log-control-btn"
              type="button"
              data-testid="clear-debug-log"
            >
              Clear Log
            </button>
            <button
              id="copy-debug-log"
              class="log-control-btn"
              type="button"
              data-testid="copy-debug-log"
            >
              Copy Log
            </button>
          </div>
        </div>
        <div id="debug-log" class="debug-log" data-testid="debug-log"></div>
      </section>

      <!-- Chat Interface -->
      <section id="chat-interface" class="section hidden" data-testid="chat-interface">
        <h2>Chat</h2>
        <div class="chat-container">
          <div id="chat-messages" class="chat-messages" data-testid="chat-messages">
            <!-- Messages will appear here -->
          </div>
          <div class="chat-input-container">
            <input 
              type="text" 
              id="chat-input"
              data-testid="chat-input"
              placeholder="Type a message..."
            />
            <button 
              id="send-message-btn"
              class="action-button"
              data-testid="send-message-btn"
            >
              Send
            </button>
          </div>
        </div>
      </section>

      <!-- Error Display -->
      <section id="error-section" class="section error-section hidden" data-testid="error-section">
        <h2>Error</h2>
        <div class="error-box" id="error-box" data-testid="error-box"></div>
      </section>

      <!-- Close Room -->
      <section class="section actions-section">
        <button 
          id="close-room-btn"
          class="action-button danger-button hidden"
          data-testid="close-room-btn"
        >
          Close Room
        </button>
      </section>
    </main>
  </div>

  <script type="module">
    import { WebRTCRegistryClient, ConnectionState } from './src/webrtc/index.ts';

    let client = null;
    let currentRole = null;

    // DOM Elements
    const registryUrlInput = document.getElementById('registry-url');
    const stunUrlInput = document.getElementById('stun-url');
    const roleHostBtn = document.getElementById('role-host');
    const roleGuestBtn = document.getElementById('role-guest');
    const hostInterface = document.getElementById('host-interface');
    const guestInterface = document.getElementById('guest-interface');
    const chatInterface = document.getElementById('chat-interface');
    const errorSection = document.getElementById('error-section');
    const errorBox = document.getElementById('error-box');
    const stateText = document.getElementById('state-text');
    const stateIndicator = document.getElementById('state-indicator');
    const debugLog = document.getElementById('debug-log');
    const copyDebugLogBtn = document.getElementById('copy-debug-log');
    const clearDebugLogBtn = document.getElementById('clear-debug-log');
    const collapseDebugLogBtn = document.getElementById('collapse-debug-log');
    const closeRoomBtn = document.getElementById('close-room-btn');

    const MAX_DEBUG_ENTRIES = 60;
    const debugEvents = [];
    const stateTimestamps = new Map();
    stateTimestamps.set(ConnectionState.IDLE, Date.now());

    let isLogCollapsed = false;
    let lastLoggedErrorStateTimestamp = null;
    let expectingErrorPayload = false;
    let pendingErrorTimer = null;

    // Host elements
    const hostUsernameInput = document.getElementById('host-username');
    const createRoomBtn = document.getElementById('create-room-btn');
    const roomCreatedInfo = document.getElementById('room-created-info');
    const roomCodeSpan = document.getElementById('room-code');
    const joinCodeSpan = document.getElementById('join-code');
    const expiresAtSpan = document.getElementById('expires-at');
    const startConnectionHostBtn = document.getElementById('start-connection-host-btn');
    const copyRoomCodeBtn = document.getElementById('copy-room-code');
    const copyJoinCodeBtn = document.getElementById('copy-join-code');

    // Guest elements
    const guestUsernameInput = document.getElementById('guest-username');
    const guestRoomCodeInput = document.getElementById('guest-room-code');
    const guestJoinCodeInput = document.getElementById('guest-join-code');
    const joinRoomBtn = document.getElementById('join-room-btn');
    const roomJoinedInfo = document.getElementById('room-joined-info');
    const hostNameSpan = document.getElementById('host-name');
    const startConnectionGuestBtn = document.getElementById('start-connection-guest-btn');

    // Chat elements
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendMessageBtn = document.getElementById('send-message-btn');

    if (copyDebugLogBtn) {
      copyDebugLogBtn.addEventListener('click', copyDebugLog);
    }

    if (clearDebugLogBtn) {
      clearDebugLogBtn.addEventListener('click', clearDebugLog);
    }

    if (collapseDebugLogBtn) {
      collapseDebugLogBtn.addEventListener('click', toggleDebugLogCollapse);
    }

    // Initialize client
    function initializeClient() {
      const registryApiUrl = registryUrlInput.value.trim();
      const stunUrl = stunUrlInput.value.trim();

      if (!registryApiUrl || !stunUrl) {
        showError('Please provide Registry API URL and STUN server URL');
        return false;
      }

      if (debugLog) {
        debugLog.innerHTML = '';
      }
      debugEvents.length = 0;
      stateTimestamps.clear();
      recordStateTimestamp(ConnectionState.IDLE, Date.now());
      lastLoggedErrorStateTimestamp = null;
      expectingErrorPayload = false;
      if (pendingErrorTimer !== null) {
        clearTimeout(pendingErrorTimer);
        pendingErrorTimer = null;
      }

      client = new WebRTCRegistryClient({
        registryApiUrl,
        iceServers: [{ urls: stunUrl }]
      });

      client.onStateChange((state) => {
        updateState(state);
        if (state === ConnectionState.CONNECTED) {
          chatInterface.classList.remove('hidden');
        }
        if (state === ConnectionState.ERROR) {
          const errorStateTimestamp = stateTimestamps.get(state) ?? Date.now();
          if (pendingErrorTimer !== null) {
            clearTimeout(pendingErrorTimer);
          }
          expectingErrorPayload = true;
          pendingErrorTimer = setTimeout(() => {
            if (!expectingErrorPayload) {
              return;
            }
            addErrorEvent({
              state,
              message: 'Entered error state without diagnostics payload',
              timestamp: Date.now(),
              stateTimestamp: errorStateTimestamp,
            });
            lastLoggedErrorStateTimestamp = errorStateTimestamp;
            expectingErrorPayload = false;
            pendingErrorTimer = null;
          }, 200);
        } else {
          expectingErrorPayload = false;
          if (pendingErrorTimer !== null) {
            clearTimeout(pendingErrorTimer);
            pendingErrorTimer = null;
          }
        }
      });

      client.onMessage((message) => {
        addChatMessage(message.text, 'peer');
      });

      client.onError((error) => {
        handleClientError(error);
      });

      client.onDebugEvent((event) => {
        addDebugEvent(event);
      });

      return true;
    }

    // Role selection
    roleHostBtn.addEventListener('click', () => {
      currentRole = 'host';
      roleHostBtn.classList.add('active');
      roleGuestBtn.classList.remove('active');
      hostInterface.classList.remove('hidden');
      guestInterface.classList.add('hidden');
      if (!client && !initializeClient()) return;
    });

    roleGuestBtn.addEventListener('click', () => {
      currentRole = 'guest';
      roleGuestBtn.classList.add('active');
      roleHostBtn.classList.remove('active');
      guestInterface.classList.remove('hidden');
      hostInterface.classList.add('hidden');
      if (!client && !initializeClient()) return;
    });

    // Host: Create room
    createRoomBtn.addEventListener('click', async () => {
      const username = hostUsernameInput.value.trim();
      if (!username) {
        showError('Please enter a username');
        return;
      }

      try {
        await client.createRoom(username);
        const roomInfo = client.getRoomInfo();
        
        roomCodeSpan.textContent = roomInfo.code;
        joinCodeSpan.textContent = roomInfo.joinCode || 'N/A';
        expiresAtSpan.textContent = new Date(roomInfo.expiresAt).toLocaleString();
        
        roomCreatedInfo.classList.remove('hidden');
        closeRoomBtn.classList.remove('hidden');
        createRoomBtn.disabled = true;
      } catch (error) {
        showError(`Failed to create room: ${error.message}`);
      }
    });

    // Guest: Join room
    joinRoomBtn.addEventListener('click', async () => {
      const username = guestUsernameInput.value.trim();
      const roomCode = guestRoomCodeInput.value.trim();
      const joinCode = guestJoinCodeInput.value.trim();

      if (!username || !roomCode || !joinCode) {
        showError('Please fill in all fields');
        return;
      }

      try {
        await client.joinRoom(roomCode, joinCode, username);
        const roomInfo = client.getRoomInfo();
        
        hostNameSpan.textContent = roomInfo.hostUserName || 'Unknown';
        roomJoinedInfo.classList.remove('hidden');
        closeRoomBtn.classList.remove('hidden');
        joinRoomBtn.disabled = true;
      } catch (error) {
        showError(`Failed to join room: ${error.message}`);
      }
    });

    // Start connection
    startConnectionHostBtn.addEventListener('click', async () => {
      try {
        await client.startConnection();
        startConnectionHostBtn.disabled = true;
      } catch (error) {
        showError(`Failed to start connection: ${error.message}`);
      }
    });

    startConnectionGuestBtn.addEventListener('click', async () => {
      try {
        await client.startConnection();
        startConnectionGuestBtn.disabled = true;
      } catch (error) {
        showError(`Failed to start connection: ${error.message}`);
      }
    });

    // Copy buttons
    copyRoomCodeBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(roomCodeSpan.textContent);
    });

    copyJoinCodeBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(joinCodeSpan.textContent);
    });

    // Chat
    sendMessageBtn.addEventListener('click', sendChatMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendChatMessage();
    });

    function sendChatMessage() {
      const text = chatInput.value.trim();
      if (!text) return;

      try {
        client.sendMessage({ text });
        addChatMessage(text, 'self');
        chatInput.value = '';
      } catch (error) {
        showError(`Failed to send message: ${error.message}`);
      }
    }

    function addChatMessage(text, sender) {
      const messageEl = document.createElement('div');
      messageEl.className = `chat-message ${sender}`;
      messageEl.textContent = text;
      chatMessages.appendChild(messageEl);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function handleClientError(error) {
      const message = error instanceof Error ? error.message : String(error);
      const timestamp = Date.now();
      const state = client && typeof client.getConnectionState === 'function'
        ? client.getConnectionState()
        : ConnectionState.ERROR;
      const stateTimestamp = stateTimestamps.get(state) ?? timestamp;
      const diagnostics = extractDiagnostics(error);

      addErrorEvent({
        state,
        message,
        timestamp,
        stateTimestamp,
        diagnostics,
        error,
      });
      lastLoggedErrorStateTimestamp = stateTimestamp;
      expectingErrorPayload = false;
      if (pendingErrorTimer !== null) {
        clearTimeout(pendingErrorTimer);
        pendingErrorTimer = null;
      }
      showError(message);
    }

    function extractDiagnostics(error) {
      if (!error || typeof error !== 'object') {
        return null;
      }

      if ('diagnostics' in error && error.diagnostics) {
        return error.diagnostics;
      }

      if ('details' in error && error.details) {
        return error.details;
      }

      if ('info' in error && error.info) {
        return error.info;
      }

      if (error.cause && typeof error.cause === 'object') {
        return extractDiagnostics(error.cause);
      }

      return null;
    }

    function addDebugEvent(event) {
      const normalizedEvent = sanitizeForLogging({ ...event });
      storeDebugEvent(normalizedEvent);
      renderDebugEntry(normalizedEvent);
    }

    function addErrorEvent({ state, message, timestamp, stateTimestamp, diagnostics, error }) {
      const errorPayload = {
        type: 'error-state',
        state,
        message,
        timestamp,
        stateTimestamp,
        diagnostics: diagnostics ?? null,
        error: error ? sanitizeForLogging(error) : null,
      };

      if (errorPayload.error && typeof errorPayload.error === 'object') {
        const rawError = errorPayload.error;
        if (rawError && typeof rawError === 'object') {
          if (rawError.code !== undefined) {
            errorPayload.code = rawError.code;
          }
          if (rawError.retryable !== undefined) {
            errorPayload.retryable = rawError.retryable;
          }
          if (rawError.status !== undefined) {
            errorPayload.status = rawError.status;
          }
          if (!errorPayload.diagnostics && rawError.diagnostics) {
            errorPayload.diagnostics = rawError.diagnostics;
          }
        }
      }

      if (errorPayload.diagnostics) {
        errorPayload.diagnostics = sanitizeForLogging(errorPayload.diagnostics);
      }

      storeDebugEvent(errorPayload);
      renderDebugEntry(errorPayload);
    }

    function storeDebugEvent(event) {
      debugEvents.push(event);
      while (debugEvents.length > MAX_DEBUG_ENTRIES) {
        debugEvents.shift();
      }
    }

    function renderDebugEntry(event) {
      if (!debugLog) return;

      const entry = document.createElement('div');
      entry.className = 'debug-entry';
      entry.dataset.eventType = event.type;

      if (event.type === 'candidate-error' || event.type === 'error-state') {
        entry.classList.add('debug-entry-error');
      }

      if (event.type === 'candidate-buffered') {
        entry.classList.add('debug-entry-buffered');
      }

      if (event.type === 'error-state') {
        entry.classList.add('debug-entry-fatal');
      }

      const header = document.createElement('div');
      header.className = 'debug-entry-header';

      const typeSpan = document.createElement('span');
      typeSpan.className = 'debug-entry-type';
      const typeLabel = formatDebugEventType(event.type);
      typeSpan.textContent = event.state ? `${typeLabel} (${event.state})` : typeLabel;

      const timeSpan = document.createElement('span');
      timeSpan.className = 'debug-entry-time';
      timeSpan.textContent = formatTimestamp(event.timestamp);
      if (event.stateTimestamp && event.stateTimestamp !== event.timestamp) {
        timeSpan.title = `State timestamp: ${formatTimestamp(event.stateTimestamp)}`;
      }

      header.appendChild(typeSpan);
      header.appendChild(timeSpan);

      const message = document.createElement('div');
      message.className = 'debug-entry-message';
      message.textContent = describeDebugEvent(event);

      entry.appendChild(header);
      entry.appendChild(message);

      if (event.diagnostics && Object.keys(event.diagnostics).length > 0) {
        const diagnosticsBlock = document.createElement('pre');
        diagnosticsBlock.className = 'debug-entry-diagnostics';
        diagnosticsBlock.textContent = formatDiagnostics(event.diagnostics);
        entry.appendChild(diagnosticsBlock);
      }

      debugLog.prepend(entry);

      while (debugLog.childElementCount > MAX_DEBUG_ENTRIES) {
        debugLog.removeChild(debugLog.lastElementChild);
      }
    }

    function copyDebugLog() {
      if (!debugEvents.length) {
        showError('No debug events to copy yet');
        return;
      }

      const logText = buildDebugLogText();

      if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
        try {
          fallbackCopyToClipboard(logText);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          showError(`Failed to copy log: ${message}`);
        }
        return;
      }

      navigator.clipboard.writeText(logText).catch(() => {
        try {
          fallbackCopyToClipboard(logText);
        } catch (fallbackError) {
          const message =
            fallbackError instanceof Error ? fallbackError.message : String(fallbackError);
          showError(`Failed to copy log: ${message}`);
        }
      });
    }

    function buildDebugLogText() {
      return debugEvents
        .map((event) => {
          const timestamp = new Date(event.timestamp ?? Date.now()).toISOString();
          const description = describeDebugEvent(event);
          const serialized = JSON.stringify(event, getCircularReplacer(), 2);
          const lines = [`[${timestamp}] ${event.type}`];
          if (description && description !== event.type) {
            lines.push(description);
          }
          lines.push(serialized);
          return lines.join('\n');
        })
        .join('\n\n');
    }

    function getCircularReplacer() {
      const seen = new WeakSet();
      return (key, value) => {
        if (value instanceof Error) {
          return {
            name: value.name,
            message: value.message,
            stack: value.stack,
          };
        }

        if (typeof value === 'object' && value !== null) {
          if (seen.has(value)) {
            return '[Circular]';
          }
          seen.add(value);
        }
        return value;
      };
    }

    function sanitizeForLogging(value, seen) {
      if (value === null || typeof value !== 'object') {
        return value;
      }

      const tracker = seen ?? new WeakSet();
      if (tracker.has(value)) {
        return '[Circular]';
      }
      tracker.add(value);

      if (value instanceof Date) {
        return value.toISOString();
      }

      if (value instanceof Error) {
        const base = {
          name: value.name,
          message: value.message,
        };
        if (value.stack) {
          base.stack = value.stack;
        }
        for (const key of Object.keys(value)) {
          if (key in base) continue;
          base[key] = sanitizeForLogging(value[key], tracker);
        }
        return base;
      }

      if (Array.isArray(value)) {
        return value.map((item) => sanitizeForLogging(item, tracker));
      }

      if (value instanceof Map) {
        return Array.from(value.entries()).map(([key, val]) => [key, sanitizeForLogging(val, tracker)]);
      }

      if (value instanceof Set) {
        return Array.from(value.values()).map((item) => sanitizeForLogging(item, tracker));
      }

      const output = {};
      for (const [key, val] of Object.entries(value)) {
        if (typeof val === 'function') {
          continue;
        }
        output[key] = sanitizeForLogging(val, tracker);
      }

      return output;
    }

    function formatTimestamp(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return new Date().toLocaleTimeString();
      }
      return new Date(value).toLocaleTimeString();
    }

    function formatDiagnostics(diagnostics) {
      if (diagnostics === null || diagnostics === undefined) {
        return '';
      }
      if (typeof diagnostics === 'string') {
        return diagnostics;
      }
      try {
        return JSON.stringify(diagnostics, getCircularReplacer(), 2);
      } catch (error) {
        return String(diagnostics);
      }
    }

    function fallbackCopyToClipboard(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);

      const selection = document.getSelection();
      const selectedRange = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;

      textarea.select();
      textarea.setSelectionRange(0, textarea.value.length);

      const successful = typeof document.execCommand === 'function'
        ? document.execCommand('copy')
        : false;

      document.body.removeChild(textarea);

      if (selectedRange && selection) {
        selection.removeAllRanges();
        selection.addRange(selectedRange);
      }

      if (!successful) {
        throw new Error('Clipboard copy was not permitted');
      }
    }

    function formatDebugEventType(type) {
      switch (type) {
        case 'room-snapshot':
          return 'Room Poll';
        case 'offer-posted':
          return 'Offer';
        case 'answer-posted':
          return 'Answer';
        case 'remote-description-set':
          return 'Remote SDP';
        case 'candidate-sent':
          return 'Candidate Out';
        case 'candidate-buffered':
          return 'Candidate Buffered';
        case 'candidate-applied':
          return 'Candidate In';
        case 'candidate-error':
          return 'Candidate Error';
        case 'peer-connection-error':
          return 'Peer Error';
        case 'peer-connection-state':
          return 'Peer State';
        case 'data-channel-state':
          return 'Data Channel';
        case 'error-state':
          return 'Error State';
        default:
          return type;
      }
    }

    function describeDebugEvent(event) {
      switch (event.type) {
        case 'room-snapshot':
          return `Room status: ${event.status} (offer: ${event.hasOffer ? 'yes' : 'no'}, answer: ${event.hasAnswer ? 'yes' : 'no'})`;
        case 'offer-posted':
          return 'Offer posted to registry';
        case 'answer-posted':
          return 'Answer posted to registry';
        case 'remote-description-set':
          return `Remote description set (${event.descriptionType})`;
        case 'candidate-sent':
          return `Sent ICE candidate ${summarizeCandidate(event.candidateKey, event.candidate)}`;
        case 'candidate-buffered':
          return `Buffered ICE candidate ${summarizeCandidate(event.candidateKey, event.candidate)}`;
        case 'candidate-applied':
          return `Applied ICE candidate ${summarizeCandidate(event.candidateKey, event.candidate)}`;
        case 'candidate-error':
          return `Candidate issue (${event.candidateKey}): ${event.message}`;
        case 'peer-connection-error':
          return `Peer connection error (${event.state}): ${event.reason}`;
        case 'peer-connection-state':
          return `Peer connection state changed to ${event.state}`;
        case 'data-channel-state':
          return `Data channel "${event.label}" is ${event.state}`;
        case 'error-state': {
          const parts = [];
          if (event.stateTimestamp) {
            parts.push(`Entered ${event.state} at ${formatTimestamp(event.stateTimestamp)}`);
          } else if (event.state) {
            parts.push(`State: ${event.state}`);
          }
          if (event.message) {
            parts.push(`Message: ${event.message}`);
          }
          if (event.code !== undefined) {
            parts.push(`Code: ${event.code}`);
          }
          if (event.status !== undefined) {
            parts.push(`Status: ${event.status}`);
          }
          if (event.retryable !== undefined) {
            parts.push(`Retryable: ${event.retryable}`);
          }
          if (event.diagnostics && Object.keys(event.diagnostics).length > 0) {
            parts.push(
              typeof event.diagnostics === 'string'
                ? `Diagnostics: ${event.diagnostics}`
                : 'Diagnostics attached'
            );
          }
          return parts.join('\n');
        }
        default:
          return event.type;
      }
    }

    function summarizeCandidate(candidateKey, candidate) {
      const keySuffix = candidateKey ? candidateKey.slice(0, 8) : 'n/a';
      const text = candidate || 'empty';
      const truncated = text.length > 60 ? `${text.slice(0, 60)}…` : text;
      return `[${keySuffix}] ${truncated}`;
    }

    function clearDebugLog() {
      debugEvents.length = 0;
      if (debugLog) {
        debugLog.innerHTML = '';
      }
    }

    function toggleDebugLogCollapse() {
      isLogCollapsed = !isLogCollapsed;
      if (!debugLog || !collapseDebugLogBtn) return;

      if (isLogCollapsed) {
        debugLog.classList.add('collapsed');
        collapseDebugLogBtn.textContent = 'Expand Entries';
        collapseDebugLogBtn.setAttribute('aria-pressed', 'true');
      } else {
        debugLog.classList.remove('collapsed');
        collapseDebugLogBtn.textContent = 'Collapse Entries';
        collapseDebugLogBtn.setAttribute('aria-pressed', 'false');
      }
    }

    function recordStateTimestamp(state, timestamp = Date.now()) {
      stateTimestamps.set(state, timestamp);
    }

    // Close room
    closeRoomBtn.addEventListener('click', async () => {
      try {
        await client.closeRoom();
        location.reload();
      } catch (error) {
        showError(`Failed to close room: ${error.message}`);
      }
    });

    // Update state display
    function updateState(state) {
      const timestamp = Date.now();
      stateText.textContent = state;
      stateIndicator.className = `state-indicator state-${state}`;
      recordStateTimestamp(state, timestamp);
    }

    // Show error
    function showError(message) {
      errorBox.textContent = message;
      errorSection.classList.remove('hidden');
      setTimeout(() => {
        errorSection.classList.add('hidden');
      }, 5000);
    }
  </script>
</body>
</html>